\documentclass[a4paper,12pt]{report}

\usepackage{alltt, fancyvrb, url}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{float}
\usepackage{hyperref}

\usepackage[italian]{babel}

\usepackage[italian]{cleveref}

\title{Relazione \\``SMOL''}

\author{Ettore Farinelli \\ Marco Galeri \\ Giovanni Paradisi \\ Mounir Samite}
\date{\today}


\begin{document}

\maketitle

\tableofcontents


%------------------------------ANALISI------------------------------
\chapter{Analisi}

%REQUISITI
\section{Requisiti}
Il gruppo si pone come obiettivo quello di realizzare un videogioco 2D arcade con visuale dall’alto di nome "SMOL".
Per arcade si intende una struttura di gioco ripetitiva in cui l'obbiettivo è accumulare più punti possibile.
%

\subsubsection{Requisiti funzionali}
\begin{itemize}
    \item Il software dovrà essere in grado di gestire l'ambiente di gioco durante l'intera durata della partita elaborando le interazioni tra le diverse entità del gioco.
    \item L’obbiettivo del gioco è difendere i campi di ortaggi dalle talpe che invadono la mappa, schiacciandole con un martello. I campi subiranno danni anche in caso 
        il giocatore li attraversi.
    \item Con il progredire dello score la difficoltà di gioco aumenterà, diminuendo il tempo tra la creazione di talpe e modificando la probabilità 
        con cui si generano diversi tipi di talpa.
    \item Durante la partita sarà possibile effetuare diverse operazioni:
    \begin{itemize}
        \item Il giocatore potrà muovere il personaggio, attraverso i tasti direzionali, all’interno della mappa.
        \item Usando il mouse invece, controllerà la direzione del martello che attraverso una pressione prolungata potrà aumentare il raggio di azione.
    \end{itemize}
    \item Il gioco termina quando tutti gli ortaggi risultano distrutti.
\end{itemize}
\subsubsection{Requisiti non funzionali}
\begin{itemize}
    \item Si avrà la possibilità di cambiare l'aspetto grafico scegliendo tra quelli proposti nell'interfaccia del menù.
    \item Il programma sarà in grado di salvare il miglior punteggio in locale.
    \item Il gioco avrà una sezione in cui verrano visualizzate le istruzioni di gioco.
    \item Implementazione di una pagina di game over che permette di tornare al menù senza chiudere l'applicazione e 
        mantenendo lo stesso pacchetto grafico precedentemente utilizzato.
\end{itemize}
%ANALISI E MODELLO DEL DOMINIO
\section{Analisi e modello del dominio}
In SMOL il sofware dovrà essere in grado di controllare le interazioni tra diverse tipologie di entità. 
Tra le entità saranno presenti:
\begin{itemize}
    \item Ortaggi: queste entità fungeranno come vita del giocatore ed a contatto con altre entità perderanno vita
    \item Giocatore: questa entità sarà controllata attraverso la tastiera e permetterà di spostarsi all'interno della mappa.
    \item Martello: questa entità sarà controllata attraverso il mouse che, con una pressione prolungata permetterà di aumentare 
        il proprio raggio di azione, mentre al rilascio, se si troverà a contatto con le talpe, gli toglierà vita.
    \item Talpe: questa entità fungerà da nemico principale del giocatore, spostandosi attraverso la mappa cercherà di mangiare 
        gli ortaggi presenti ed in caso entri in contatto col giocatore gli bloccherà temporaneamente i movimenti.
    \item Muri: impediranno al giocatore di uscire dai confini della mappa di gioco.
\end{itemize}
Il sofware sarà responsabile anche della creazione iniziale degli ortaggi e la generazione delle talpe durante il resto della 
partita attraverso un sistema che incrementerà in base al punteggio corrente del giocatore il numero di talpe generate nel tempo, 
insieme alla probabilità di generare talpe più complicate da abbattere.
Gli elementi costitutivi del dominio sono sintetizzati in %\Cref{img:analysisScheme}.
Per rientrare nel monte ore richiesto non è stato possibile implementare una modalità di multiplayer locale, 
che sarà possibilmente implementata in futuro.

\begin{figure}[H]
\centering{}
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{img/AnalysisUML.png}
\caption{Schema UML dell'analisi del problema, con rappresentate le entità principali ed i rapporti fra loro}
\label{img:analysisScheme}
\end{figure}

%------------------------------DESIGN------------------------------
\chapter{Design}

%ARCHITETTURA
\section{Architettura}

L'architettura di GLaDOS segue il pattern architetturale MVC.
%
Più nello specifico, a livello architetturale, si è scelto di utilizzare MVC in forma ``ECB'', ossia ``entity-control-boundary''\footnote{
Si fa presente che il pattern ECB effettivamente esiste in letteratura come ``istanza'' di MVC, e chi volesse può utilizzarlo come reificazione di MVC.
}.
%
GLaDOS implementa l'interfaccia AI, ed è il controller del sistema.
Essendo una intelligenza artificiale, è una classe attiva.
%
GLaDOS accetta la registrazione di Input ed Output, che fanno parte della ``view'' di MVC, e sono il ``boundary'' di ECB.
Gli Input rappresentano delle nuove informazioni che vengono fornite all'IA, ad esempio delle modifiche nel valore di un sensore, oppure un comando da parte dell'operatore.
Questi input infatti forniscono eventi.
Ottenere un evento è un'operazione bloccante: chi la esegue resta in attesa di un effettivo evento.
Di fatto, quindi, GLaDOS si configura come entità \textit{reattiva}.
Ogni volta che c'è un cambio alla situazione del soggetto, GLaDOS notifica i suoi Output,
informandoli su quale sia la situazione corrente.
%
Conseguentemente, GLaDOS è un ``observable'' per Output.

\begin{figure}[h]
\centering{}
%\includegraphics[width=\textwidth]{img/arch}
\caption{Schema UML architetturale di GLaDOS. L'interfaccia \texttt{GLaDOS} è il controller del sistema, mentre \texttt{Input} ed \texttt{Output} sono le interfacce che mappano la view (o, più correttamente in questo specifico esempio, il boundary). Un'eventuale interfaccia grafica interattiva dovrà implementarle entrambe.}
\label{img:goodarch}
\end{figure}

Con questa architettura, possono essere aggiunti un numero arbitrario di input ed output
all'intelligenza artificiale.
%
Ovviamente, mentre l'aggiunta di output è semplice e non richiede alcuna modifica all'IA, la
presenza di nuovi tipi di evento richiede invece in potenza aggiunte o rifiniture a GLaDOS.
%
Questo è dovuto al fatto che nuovi Input rappresentano di fatto nuovi elementi della business
logic, la cui alterazione od espansione inevitabilmente impatta il controller del progetto.

%In \Cref{img:goodarch} è esemplificato il diagramma UML architetturale.

%DESIGN DETTAGLIATO%DESIGN DETTAGLIATO
\section{Design dettagliato}

\subsection*{Ettore Farinelli}
\subsubsection{Implementazione degli input del giocatore}
\begin{figure}[H]
\centering{}
\includegraphics[scale = 0.5]{img/KeyInputsUML.PNG}
\caption{Schema UML rappresentante il ricevimento degli input della classe \emph{KeyInputs}.}
\end{figure}
\paragraph{Problema}
    Un input inserito da tastiera deve essere elaborato e immagazzinato cosi da permettere al player di muoversi.
\paragraph{Soluzione}
    Ogni input inserito da tastiera viene ricevuto e passato alla classe \emph{KeyInputs} che lo filtra e in base al tipo  
    inserisce una \emph{Direction} all'interno di una coda che verrà successivamente svuotata un elemento alla volta 
    dall'\emph{InputComponent} (in questo caso dal \emph{PlayerInputComponent}) ricevendo così le direzioni che verranno 
    applicate all'entità stessa pemrettendole di muoversi nella mappa di gioco, Come da figura\ref{img:PlayerMovement}.
\begin{figure}[H]
\centering{}
\includegraphics[scale = 0.5]{img/PlayerMovement.PNG}
\caption{Schema UML che rappresenta in che modo un input venga elaborato e ricevuto da un entità.}
\label{img:PlayerMovement}
\end{figure}

\subsubsection{Gestione del martello}
\begin{figure}[H]
\centering{}
\includegraphics[scale = 0.5]{img/MouseInputsUML.PNG}
\caption{Schema UML rappresentante il ricevimento degli input della classe \emph{MouseInputs}.}
\end{figure}
\paragraph{Problema}
    Il martello dovrà avere una posizione risultante distante dal giocatore di una misura uguale al raggio della circonferenza 
    di diamentro \textsc{weaponRange} e in una posizione presente nella retta tracciata dal centro del giocatore al cursore del mouse.
    Inoltre quando il martello viene rilasciato dovrà bloccare gli input per permettere al player (virtualmente) di colpire con 
    il martello la talpa su cui il bersaglio si trova.
\paragraph{Soluzione}
    Come per il problema degli input da tastiera, quelli da mouse vengono ricevuti e elaborati in maniera simile con una differenza
    sostanziale. Infatti, \emph{MouseInputs} salva direttamente la posizione del cursore
    quando viene mosso o rilasciato, che viene quindi ricevuta dall'\emph{InputComponent} e poi elaborata nel \emph{PhysicComponent} 
    dove vengono quindi fatti tutti i calcoli \footnote{\url{https://github.com/TheDarkRuler/OOP22-SMOL/blob/757228125cb2531fccca35b35f7645ceba9d5ae9/src/main/java/it/unibo/smol/model/impl/physicscomponent/WeaponPhysicsComponent.java#L46-L51}} 
    per trovare la effettiva posizione in cui il martello colpirà al rilascio \ref{img:MouseInputs}. Sempre al rilascio del tasto sinistro del mouse, 
    per bloccare gli input da tastiera e da mouse inizialmente ho pensato di utilizzare dei metodi, e quindi campi, statici 
    accessibili sia da \emph{MouseInputs} che da \emph{KeyInputs}, infine poi, a seguito di diverse migliorie 
    ho optato per includere un campo di tipo \emph{KeyInputs} all'interno di \emph{MouseInputs} così da poter notificare il blocco 
    degli input da una classe all'altra.
\begin{figure}[H]
\centering{}
\includegraphics[scale = 0.5]{img/MouseInputs.PNG}
\caption{Schema UML che rappresenta in che modo un input venga elaborato e ricevuto da un entità.}
\label{img:MouseInputs}
\end{figure}

\subsubsection{Creazione AI talpe}
\begin{figure}[H]
\centering{}
\includegraphics[scale = 0.4]{img/EnemyInputs.PNG}
\caption{Schema UML rappresentante lo schema di ereditarietà della classe EnemyInput.}
\end{figure}

\paragraph{Problema}
    Creare un intelligenza artificiale che scelga una posizione, dove non siano presenti altre entità al momento, in modo 
    pseudo-casuale e che sia adattabile a 4 diversi tipi di entità. Inoltre essa deve effettivamente muoversi nella mappa 
    in maniera uniforme.
\paragraph{Soluzione}
    
\subsection*{Marco Galeri}

\subsubsection{Gestione delle Entità}

\begin{figure}[H]
\centering
    \includegraphics[width=\textwidth,height=2\textheight,keepaspectratio]{img/EntityUML.png}
    \caption{Rappresentazione UML di una entità e i suoi componenti}
\end{figure}

\paragraph{Problema}
    L'interfaccia \textsc{Entity} deve implementare numerosi comportamenti diversi, l'uso dell'ereditarietà porterebbe alla creazione di molteplici sottoclassi ed a possibili problemi di eredità multipla aumentando la complessità del codice. Inoltre la classe \textsc{Entity} incapsula diversi aspetti del gioco violando il \textit{Single Responsability Principle}.

\paragraph{Soluzione}
    Adottando l'\textit{Entity Component System}, ampiamente usato nell'ambito di Game Development, si ha una scissione dei vari aspetti di gioco in \textsc{components}. L'unione dei \textsc{components} quindi definisce il comportamento finale di ogni Entità. Con questo design che favorisce la composizione al posto dell'ereditarietà si ha un aumento di flessibilità del codice che viene suddiviso in classi più corte e meno complicate. Inoltre i componenti sono altamente riusabili rendendo plausibile la creazione di diverse tipologie di entità e lasciando libera la possibilità di aggiunte future.

\subsubsection{Creazione delle Entità}

\begin{figure}[H]
\centering{}
\includegraphics[width=0.75\textwidth,keepaspectratio]{img/EntityFactoryUML.png}
\caption{Rappresentazione UML della creazione di una entità attraverso l'utilizzo del Factory method}
\end{figure}

\paragraph{Problema}
    Date le molteplici tipologie di componenti che una Entità può avere, la creazione di un'Entità direttamente all'interno del mondo è possibile ma poco flessibile e funzionale. 
    
\paragraph{Soluzione}
    Impiegando il \textit{Factory design pattern},  la creazione dell'entità viene esternalizzata in una classe. Con questa classe, \textsc{EntityFactory}, si possono creare dei set di componenti predefiniti da usare per istanziare ogni tipo di entità. Attraverso questo metodo si diminuisce notevolmente la duplicazione di codice, inoltre si rimuove la responsabilità di creazione delle entità dalla classe chiamante. 

\subsubsection{Gestione del movimento e risoluzione delle collisioni tra Entità}

\begin{figure}[H]
\centering{}
\includegraphics[width=1\textwidth,keepaspectratio]{img/PhysicsComponentUML.png}
\caption{Rappresentazione UML delle diverse interazioni tra Entità}
\end{figure}

\paragraph{Problema}
\begin{itemize}
    \item Entità diverse ricevono comandi di movimento differenti rendendo complicato creare una interfaccia generale che gestisca la fisica delle entità.
    \item Le collisioni devono produrre eventi differenti in base alle tipologie di Entità che stanno collidendo.
\end{itemize}

\paragraph{Soluzione}
    Utilizzando un \textit{Template method pattern} si ha la possibilità di definire una struttura generale della classe, lasciando alle sottoclassi la scelta di dettagli specifici. Questo riduce drasticamente la duplicazione di codice in quanto i metodi template \texttt{checkCollision()} e \texttt{receiveMovement()} vengono scritti unicamente nella classe madre. Inoltre tramite l'overload del metodo \texttt{receiveMovement()} viene generalizzata anche la funzione di movimento.
    
\subsubsection{Gestione di input multipli}

\begin{figure}[H]
\centering{}
\includegraphics[width=\textwidth,keepaspectratio]{img/InputComponentUML.png}
\caption{Rappresentazione UML della gestione degli InputComponent}
\end{figure}

\paragraph{Problema}
\begin{itemize}
    \item L'utilizzo di diverse implementazioni di input richiede la presenza di una interfaccia generale che li gestisca
    \item L'implementazione di nuove periferiche di gioco può risultare scomodo e macchinoso
\end{itemize}
\paragraph{Soluzione}
L'utilizzo di uno \textit{Strategy pattern} consente di isolare le diverse implementazioni di \textsc{InputComponent} randendole facilmente intercambiali e propense ad aggiunte future.
    
\subsection*{Giovanni Paradisi}
roba di Giovanni
\subsection*{Mounir Samite}
\subsubsection*{Gestione delle finestre}
\begin{figure}[h]
\centering{}
\includegraphics[width=1\textwidth]{img/WindowManagement.png}
\caption{Schema UML della gestione delle finestre del gioco usando lo state pattern}
\end{figure}
\paragraph*{Problema} gestire le finestre del software, favorendo la modularità.
\paragraph*{Soluzione} Il pattern State è utile per gestire le finestre in un videogioco con JavaFX poiché 
consente di gestire lo stato di una finestra in modo dinamico e di cambiare facilmente lo stato della finestra a seconda delle esigenze 
dell'applicazione. In un videogioco, ad esempio, ci possono essere diverse finestre con diverse funzionalità, come la finestra di gioco, 
la finestra del menu, la finestra del game over e così via.
\\
Utilizzando il pattern State, si può creare una classe per ogni stato possibile della finestra e gestire i comportamenti specifici 
di ogni stato all'interno della sua classe. In questo modo, si può garantire che la finestra si comporti
 in modo corretto a seconda dello stato in cui si trova.
 \\
 In questo modo, è possibile cambiare lo stato della finestra in modo dinamico a seconda delle azioni dell'utente o del gioco stesso,
  senza dover scrivere codice ripetitivo o complicato. 
 Inoltre, questo approccio favorisce la modularità del codice, rendendolo più facile da mantenere e riutilizzare.


%------------------------------SVILUPPO------------------------------
\chapter{Sviluppo}

%TESTING
\section{Testing automatizzato}

%METODOLOGIA_DI_LAVORO
\section{Metodologia di lavoro}
un po di roba sul DVCS

\subsection*{Ettore Farinelli}
roba di Ettore
\subsection*{Marco Galeri}

Mi sono occupato di:
\begin{itemize}
    \item \emph{GameEngine} e \emph{GameLoop} (package smol.core)
    \item \emph{Entity} ed \emph{EntityFactory} (package smol.model)
    \item \emph{PhysicsComponent} e le sue sottoclassi (package smol.model)
    \item \emph{HealthComponent} (package smol.model.impl)
    \item \emph{InputComponent} (package smol.controller)
    \item rendere la grafica proporzionale allo schermo (package smol.view.GameMap)
\end{itemize}

Ho inoltre contribuito a:
\begin{itemize}
    \item \emph{GameViewState} Aggiungendo il punteggio (package smol.view)
\end{itemize}

\subsection*{Giovanni Paradisi}
roba di Giovanni
\subsection*{Mounir Samite}
Mi sono occupato di:
\begin{itemize}
    \item Progettazione dell'utilizzo delle finestre con \emph{Window} e \emph{WindowState} con cui verranno renderizzate tutti i tipi di finestre come Menu, Gioco e Game Over (\textbf{package it.unibo.smol.view});
    \item Implementazione del Menu di gioco nella classe \emph{MenuState} (\textbf{package it.unibo.smol.view});
    \item Implementazione del GameOver (fine gioco) nella classe \emph{GameOverWinState} (\textbf{package it.unibo.smol.view});
    \item Progettazione del Mondo di gioco ovvero del contenitore di tutte le entità, degli input e dello score andando a gestire alcune loro funzionalità in \emph{WorldImpl} (\textbf{package it.unibo.smol.model});
    \item Progettazione della barra della vita del player in \emph{HealthBarTankImpl} (\textbf{package it.unibo.smol.view}).
\end{itemize}
Ho inoltre contribuito a:
\begin{itemize}
    \item \emph{PlayerInputComponent} (\textbf{package it.unibo.smol.controller});
    \item \emph{WeaponInputComponent} (\textbf{package it.unibo.smol.controller});
    \item \emph{GameViewState} andando a gestire la barra della vita anche li (\textbf{package it.unibo.smol.view});
    \item \emph{GameEngine} aggiungendo le skins (che in questo caso sono intese come diversi tipi di grafica) al gioco: vettoriale e pixelata per ora (\textbf{package it.unibo.smol.core}) 
\end{itemize}

%NOTE_DI_SVILUPPO
\section{Note di sviluppo}
Siamo partiti inizialmente con un'attenta analisi del dominio del gioco e di cosa potesse essere aggiunto, cercando di rendere il gioco adeguatamente estendibile.
Dunque è stato fatto un UML generale per avere in mente il funzionamento del gioco e sono state definite tutte le principali interfacce.
Invece per quanto riguarda il workflow è stata adottata la metodologia di DVCS semplice, spiegata a lezione, con pull e push.
\subsection*{Ettore Farinelli}
roba di Ettore
\subsection*{Marco Galeri}

Il GameLoop è stato realizzato ispirandosi al capitolo "GameLoop" presente in \emph{Game Programming Patterns}\footnote{\url{https://gameprogrammingpatterns.com/}} di Robert Nystrom.

\subsubsection{Utilizzo di Stream}
\begin{itemize}
    \item Controllo delle collisioni: \url{https://github.com/TheDarkRuler/OOP22-SMOL/blob/757228125cb2531fccca35b35f7645ceba9d5ae9/src/main/java/it/unibo/smol/model/api/PhysicsComponent.java#L34-49}

\end{itemize}

\subsection*{Giovanni Paradisi}
roba di Giovanni
\subsection*{Mounir Samite}
\subsubsection*{Utilizzo di Stream per gestione delle entità}
\begin{itemize}
    \item Prendere le talpe dalla lista di entità: \url{https://github.com/TheDarkRuler/OOP22-SMOL/blob/dac2df26a7ed60c955c6ea339cb908958a450955/src/main/java/it/unibo/smol/model/impl/WorldImpl.java#L49-L55}
    \item Prendere le piante dalla lista di entità: \url{https://github.com/TheDarkRuler/OOP22-SMOL/blob/dac2df26a7ed60c955c6ea339cb908958a450955/src/main/java/it/unibo/smol/model/impl/WorldImpl.java#L63-L69}
    \item Rileva il player dalla lista di entità: \url{https://github.com/TheDarkRuler/OOP22-SMOL/blob/dac2df26a7ed60c955c6ea339cb908958a450955/src/main/java/it/unibo/smol/model/impl/WorldImpl.java#L56-L62}
\end{itemize}
\subsubsection*{Utilizzo di JavaFX}
\begin{itemize}
    \item Utilizzo di javaFX senza FXML per la gestione della health bar in \emph{GameViewState}: \url{https://github.com/TheDarkRuler/OOP22-SMOL/blob/1a17f10567507032ae1308ff28c6147b7e08646a/src/main/java/it/unibo/smol/view/impl/GameViewState.java#L164-L201}
    \item Utilizzo di FXML nel \emph{MenuState} e nel \emph{GameOverWinState}: \url{https://github.com/TheDarkRuler/OOP22-SMOL/blob/1a17f10567507032ae1308ff28c6147b7e08646a/src/main/java/it/unibo/smol/view/impl/MenuState.java#L80}
    \item Utilizzo basilare di CSS con FXML: \url{https://github.com/TheDarkRuler/OOP22-SMOL/blob/1a17f10567507032ae1308ff28c6147b7e08646a/src/main/resources/css/Menu.css}
\end{itemize}

\subsection*{Utilizzo di Lambda Expressions}
\begin{itemize}
    \item \url{https://github.com/TheDarkRuler/OOP22-SMOL/blob/1a17f10567507032ae1308ff28c6147b7e08646a/src/main/java/it/unibo/smol/view/impl/HealthBarTankImpl.java#L71-L76}
    \item \url{https://github.com/TheDarkRuler/OOP22-SMOL/blob/1a17f10567507032ae1308ff28c6147b7e08646a/src/main/java/it/unibo/smol/model/impl/WorldImpl.java#L132-L136}
\end{itemize}

%------------------------------COMMENTI_FINALI------------------------------
\chapter{Commenti finali}

un po de roba

%AUTOVALUTAZIONE_E_LAVORI_FUTURI
\section{Autovalutazione e lavori futuri}
\subsection*{Ettore Farinelli}
roba di Ettore
\subsection*{Marco Galeri}
roba di Marco
\subsection*{Giovanni Paradisi}
roba di Giovanni
\subsection*{Mounir Samite}
Inizierò dicendo che ho apprezzato molto il nostro lavoro di squadra su questo progetto. Tutti abbiamo dimostrato un grande impegno e dedizione nel raggiungere gli obiettivi prefissati, e siamo stati in grado di collaborare efficacemente per superare le sfide che abbiamo incontrato lungo il percorso.
\\
Detto ciò, riconosco che una fase analisi e progettazione non sufficientemente dettagliata all'inizio del progetto ha comportato alcune difficoltà durante lo sviluppo del software. Ci siamo trovati ad affrontare alcune complessità che avremmo potuto evitare con una pianificazione più accurata e un'analisi dettagliata dei requisiti.
\\
Nonostante questi problemi, sono soddisfatto del risultato finale del progetto. Abbiamo creato un software che superava le nostre aspettative. Tuttavia, credo che il processo sarebbe stato ancora più efficiente e produttivo se avessimo investito più tempo nella fase di analisi e progettazione.
\\
In futuro, cercherò di fare in modo che questi aspetti siano considerati in modo più approfondito fin dall'inizio del processo di sviluppo del software, in modo da massimizzare l'efficienza del nostro lavoro di squadra e ottenere risultati ancora migliori.
%DIFFICOLTA(OPZIONALE)
\section{Difficoltà incontrate e commenti per i docenti}

\textbf{opzionale}



\appendix

%------------------------------GUIDA------------------------------

\chapter{Guida utente}



\bibliographystyle{alpha}
\bibliography{report}
\begin{itemize}
	\item Abbiamo utilizzato come ispirazione durante le fasi iniziali
    \begin{itemize}
        \item la repository di gameAsALab di A. Ricci \url{https://github.com/pslab-unibo/oop-game-prog-patterns-2022}
        \item il seguente progetto degli anni precedenti \url{https://github.com/unibo-oop-projects/oop22-t2s-game}
    \end{itemize}
    \item Abbiamo preso ispirazione dal seguente sito per fare le animazioni dei bottoni nel \emph{MenuState} e \emph{GameOver}: \url{https://genuinecoder.com/javafx-animation-tutorial/}
\end{itemize}
\end{document}


\end{document}
