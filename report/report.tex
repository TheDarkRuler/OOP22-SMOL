\documentclass[a4paper,12pt]{report}

\usepackage{alltt, fancyvrb, url}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{float}
\usepackage{hyperref}

\usepackage[italian]{babel}

\usepackage[italian]{cleveref}

\title{Relazione \\``SMOL''}

\author{Ettore Farinelli \\ Marco Galeri \\ Giovanni Paradisi \\ Mounir Samite}
\date{\today}


\begin{document}

\maketitle

\tableofcontents


%------------------------------ANALISI------------------------------
\chapter{Analisi}

%REQUISITI
\section{Requisiti}
Il gruppo si pone come obiettivo quello di realizzare un videogioco 2D arcade con visuale dall’alto di nome "SMOL".
Per arcade si intende una struttura di gioco ripetitiva in cui l'obbiettivo è accumulare più punti possibile
%

\subsubsection{Requisiti funzionali}
\begin{itemize}
    \item Il software dovrà essere in grado di gestire l'ambiente di gioco durante l'intera durata della partita gestendo le interazioni tra le diverse entità del gioco.
    \item L’obbiettivo del gioco è difendere i campi di ortaggi dalle talpe che invadono la mappa, schiacciandole con un martello.
    \item All'interno della partita il giocatore potrà:
    \begin{itemize}
        \item Il giocatore controllerà il personaggio attraverso i tasti direzionali per muoversi all’interno della mappa.
        \item Usando il mouse invece, controllerà la direzione del martello che attraverso una pressione prolungata potrà aumentare il raggio di azione.
    \end{itemize}
    \item Il gioco termina quando le talpe riescono a mangiare tutti gli ortaggi.
\end{itemize}
\subsubsection{Requisiti non funzionali}
\begin{itemize}
    \item Si avrà la possibilità di cambiare l'aspetto grafico scegliendo tra quelli proposti nel interfaccia del menù
    \item Il programma sarà in grado di salvare il miglior punteggio locale
    \item Il gioco avrà una sezione in cui verrano visualizzati i comandi da utilizzare
\end{itemize}
%ANALISI E MODELLO DEL DOMINIO
\section{Analisi e modello del dominio}


%------------------------------DESIGN------------------------------
\chapter{Design}

%ARCHITETTURA
\section{Architettura}

L'architettura di GLaDOS segue il pattern architetturale MVC.
%
Più nello specifico, a livello architetturale, si è scelto di utilizzare MVC in forma ``ECB'', ossia ``entity-control-boundary''\footnote{
Si fa presente che il pattern ECB effettivamente esiste in letteratura come ``istanza'' di MVC, e chi volesse può utilizzarlo come reificazione di MVC.
}.
%
GLaDOS implementa l'interfaccia AI, ed è il controller del sistema.
Essendo una intelligenza artificiale, è una classe attiva.
%
GLaDOS accetta la registrazione di Input ed Output, che fanno parte della ``view'' di MVC, e sono il ``boundary'' di ECB.
Gli Input rappresentano delle nuove informazioni che vengono fornite all'IA, ad esempio delle modifiche nel valore di un sensore, oppure un comando da parte dell'operatore.
Questi input infatti forniscono eventi.
Ottenere un evento è un'operazione bloccante: chi la esegue resta in attesa di un effettivo evento.
Di fatto, quindi, GLaDOS si configura come entità \textit{reattiva}.
Ogni volta che c'è un cambio alla situazione del soggetto, GLaDOS notifica i suoi Output,
informandoli su quale sia la situazione corrente.
%
Conseguentemente, GLaDOS è un ``observable'' per Output.

\begin{figure}[h]
\centering{}
%\includegraphics[width=\textwidth]{img/arch}
\caption{Schema UML architetturale di GLaDOS. L'interfaccia \texttt{GLaDOS} è il controller del sistema, mentre \texttt{Input} ed \texttt{Output} sono le interfacce che mappano la view (o, più correttamente in questo specifico esempio, il boundary). Un'eventuale interfaccia grafica interattiva dovrà implementarle entrambe.}
\label{img:goodarch}
\end{figure}

Con questa architettura, possono essere aggiunti un numero arbitrario di input ed output
all'intelligenza artificiale.
%
Ovviamente, mentre l'aggiunta di output è semplice e non richiede alcuna modifica all'IA, la
presenza di nuovi tipi di evento richiede invece in potenza aggiunte o rifiniture a GLaDOS.
%
Questo è dovuto al fatto che nuovi Input rappresentano di fatto nuovi elementi della business
logic, la cui alterazione od espansione inevitabilmente impatta il controller del progetto.

In \Cref{img:goodarch} è esemplificato il diagramma UML architetturale.

%DESIGN DETTAGLIATO%DESIGN DETTAGLIATO
\section{Design dettagliato}

\subsection*{Ettore Farinelli}
roba di Ettore
\subsection*{Marco Galeri}
roba di Marco
\subsection*{Giovanni Paradisi}
roba di Giovanni
\subsection*{Mounir Samite}
roba di Mounir


%------------------------------SVILUPPO------------------------------
\chapter{Sviluppo}

%TESTING
\section{Testing automatizzato}

%METODOLOGIA_DI_LAVORO
\section{Metodologia di lavoro}
un po di roba sul DVCS

\subsection*{Ettore Farinelli}
roba di Ettore
\subsection*{Marco Galeri}
roba di Marco
\subsection*{Giovanni Paradisi}
roba di Giovanni
\subsection*{Mounir Samite}
Mi sono occupato di:
\begin{itemize}
    \item Progettazione dell'utilizzo delle finestre con \emph{Window} e \emph{WindowState} con cui verranno renderizzate tutti i tipi di finestre come Menu, Gioco e Game Over (\textbf{package it.unibo.smol.view});
    \item Implementazione del Menu di gioco nella classe \emph{MenuState} (\textbf{package it.unibo.smol.view});
    \item Implementazione del GameOver (fine gioco) nella classe \emph{GameOverWinState} (\textbf{package it.unibo.smol.view});
    \item Progettazione del Mondo di gioco ovvero del contenitore di tutte le entità, degli input e dello score andando a gestire alcune loro funzionalità in \emph{WorldImpl} (\textbf{package it.unibo.smol.model});
    \item Progettazione della barra della vita del player in \emph{HealthBarTankImpl} (\textbf{package it.unibo.smol.view}).
\end{itemize}
Ho inoltre contribuito a:
\begin{itemize}
    \item \emph{PlayerInputComponent} (\textbf{package it.unibo.smol.controller});
    \item \emph{WeaponInputComponent} (\textbf{package it.unibo.smol.controller});
    \item \emph{GameViewState} andando a gestire la barra della vita anche li (\textbf{package it.unibo.smol.view});
    \item \emph{GameEngine} aggiungendo le skins (che in questo caso sono intese come diversi tipi di grafica) al gioco: vettoriale e pixelata per ora (\textbf{package it.unibo.smol.core}) 
\end{itemize}

%NOTE_DI_SVILUPPO
\section{Note di sviluppo}
Siamo partiti inizialmente con un'attenta analisi del dominio del gioco e di cosa potesse essere aggiunto, cercando di rendere il gioco adeguatamente estendibile. 
Dunque è stato fatto un UML generale per avere in mente il funzionamento del gioco e sono state definite tutte le principali interfacce.
Invece per quanto riguarda il workflow è stata adottata la metodologia di DVCS semplice, spiegata a lezione, con pull e push.
\subsection*{Ettore Farinelli}
roba di Ettore
\subsection*{Marco Galeri}
roba di Marco
\subsection*{Giovanni Paradisi}
roba di Giovanni
\subsection*{Mounir Samite}
\subsubsection*{Utilizzo di Stream}

Permalink: \url{https://github.com/TheDarkRuler/OOP22-SMOL/blob/dac2df26a7ed60c955c6ea339cb908958a450955/
src/main/java/it/unibo/smol/model/impl/WorldImpl.java#L49-L55}


%------------------------------COMMENTI_FINALI------------------------------
\chapter{Commenti finali}

un po de roba

%AUTOVALUTAZIONE_E_LAVORI_FUTURI
\section{Autovalutazione e lavori futuri}
\subsection*{Ettore Farinelli}
roba di Ettore
\subsection*{Marco Galeri}
roba di Marco
\subsection*{Giovanni Paradisi}
roba di Giovanni
\subsection*{Mounir Samite}
roba di Mounir

%DIFFICOLTA(OPZIONALE)
\section{Difficoltà incontrate e commenti per i docenti}

\textbf{opzionale}



\appendix

%------------------------------GUIDA------------------------------

\chapter{Guida utente}



\bibliographystyle{alpha}
\bibliography{report}

\end{document}
